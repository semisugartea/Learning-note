# 前言

* 此節將字串,列表,元組,集合,字典一起討論
* 序列是指有順序的元素的數據結構,可以是列表,元組與range(),狹義上要求元素須為同一型態

# 特徵比較

|	 |字串	|列表	|元組	|集合	|字典
|----|:----:	|:---:	|:----:	|:----:	|:----:
標記方式	|''		|[,]	|(,)	|{,}	|{:}
空			|''		|[]		|()		|set()	|{}
可變性		|否		|可		|否		|可		|可
使用+相加	|可		|可		|可		|否		|否
使用*倍增	|可		|可		|可		|否		|否
巢狀結構	|否		|可		|可		|否		|否
取值		|[index]|[index]|[index]|無		|[key]
分割		|可		|可		|可		|否		|否
in運算		|可		|可		|可		|可		|可		
推導式		|否		|可		|否		|可		|否

# 使用時機

1. 字串:單一數據型態
2. 列表:經常變更且需元素重複時使用
3. 元組:不變更且需元素重複時使用
4. 集合:經常變更但不要元素重複時使用
5. 字典:需利用指定鍵對應物件時使用
	
# 拆包	packing

* 當指派的變數多餘指派的物件,會形成元組(tuple),稱為tuple packing

		>>> tup1 = "one", "two", "three"
		>>> tup1
		('one', 'two', 'three')

* 當序列指派多個變數時,會分別得到對應的值,稱為拆包, 兩者數量不同會有ValueError
	
		>>>a, b, c = (1, 2, 3)
		>>>a
		1
		>>>b
		2
		>>>c
		3
	
	* 可在其中一個變數前加星號(*),則該變數會接收多餘的元素,但不可有兩個加星號的變數
	
	
			>>>a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]	
			>>>a
			1
			>>>b
			2
			>>>c
			[3, 4, 5, 6, 7, 8]
			>>>d
			9


# 共同函數

* del obj或	del(obj)				刪除目標物件,列表與字典可單獨刪除其中的元素

* all(iterable)						判斷是否所有元素皆為True

* any(iterable)						判斷是否有任何元素為True

* enumerate(sequence, [start=0])	列舉序列中的元素,以(number,element)的形式配對,numeber從start算起,start默認為0,回傳起始配對的物件位址

* len(iterable)						回傳目標對象的元素個數

* max(iterable)						回傳目標對象的最大元素,元素需同型態,字典則比較鍵的大小

* min(iterable)						回傳目標對象的最小元素,元素需同型態,字典則比較鍵的大小

* sum(sequence)						回傳目標序列的總值

* sorted(iterable, cmp=None, key=None, reverse=False)	以列表形式回傳目標對象的元素排序後的樣子,元素需同型態,字典則比較鍵的大小,原序列不受影響

	cmp -- 比較的函數，這個具有兩個參數，參數的值都是從可疊代對象中取出，此函數必須遵守的規則為，大於則返回1，小於則返回-1，等於則返回0。
	key -- 主要是用來進行比較的元素，只有一個參數，具體的函數的參數就是取自於可疊代對象中，指定可疊代對象中的一個元素來進行排序。
	reverse -- 排序規則，reverse = True 降序 ， reverse = False 升序（默認）

# 相關函數

* map(function, sequence)			將序列元素分別傳入函數,將函數的回傳值作為新的元素,回傳新元素組成的序列,簡稱映射

* filter(function, sequence)		將序列元素分別傳入函數,若函數回傳True則保留元素,否則移除,回傳篩選後的序列			

* reduce(function, sequence[, initializer])		函數須為有兩個參數,先將序列前2個元素傳入,再將回傳值作為第一個參數,與序列的下一個元素一起傳入函數,最後回傳最終值,可將initializer作為初始參數

* zip(sequence,sequence)			將兩序列元素一對一打包成元組的形式,回傳包的位址,打包數與最短序列的元素個數相同

* zip(*(zipped sequence))				將打包後的元組拆包,回傳兩組元素的位址




